import ezdxf
import os
import json
import numpy as np
from datetime import datetime
from typing import List, Dict, Tuple

class DXFExporter:
    @staticmethod
    def generate_dxf(design_json: dict, filename: str) -> str:
        doc = ezdxf.new('R2010')
        doc.header['$INSUNITS'] = 6
        msp = doc.modelspace()
        layers = [('PIPING', 7), ('EQUIPMENT', 4), ('ANNOTATIONS', 3), ('VALVES', 1)]
        for name, color in layers:
            doc.layers.add(name=name, color=color)
        msp.add_text(f"AETHER-GEN AUTOMATED DESIGN: {design_json.get('id', 'N/A')}", dxfattribs={'layer': 'ANNOTATIONS', 'height': 1.0}).set_placement((0, 20))
        msp.add_text(f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M')}", dxfattribs={'layer': 'ANNOTATIONS', 'height': 0.5}).set_placement((0, 18))
        for component in design_json.get('components', []):
            ctype = component.get('type')
            pos = component.get('position', [0, 0, 0])
            props = component.get('properties', {})
            name = component.get('name', 'N/A')
            x, y = pos[0], pos[1]
            if ctype == 'pipe':
                start = props.get('start_pos', pos)
                end = props.get('end_pos', [pos[0]+5, pos[1], pos[2]])
                msp.add_line((start[0], start[1]), (end[0], end[1]), dxfattribs={'layer': 'PIPING'})
                mid = ((start[0]+end[0])/2, (start[1]+end[1])/2)
                msp.add_text(f"PIPE {props.get('diameter', 4)}\" - {name}", dxfattribs={'layer': 'ANNOTATIONS', 'height': 0.2}).set_placement((mid[0], mid[1] + 0.3))
            elif ctype == 'pump':
                msp.add_lwpolyline([(x-0.8, y-0.5), (x+0.8, y-0.5), (x+0.8, y+0.5), (x-0.8, y+0.5)], close=True, dxfattribs={'layer': 'EQUIPMENT'})
                msp.add_circle((x, y), radius=0.3, dxfattribs={'layer': 'EQUIPMENT'})
                msp.add_text(f"PUMP: {name}", dxfattribs={'layer': 'ANNOTATIONS', 'height': 0.3}).set_placement((x, y + 1.2))
            elif ctype == 'tank':
                msp.add_circle((x, y), radius=4, dxfattribs={'layer': 'EQUIPMENT'})
                msp.add_text(f"TANK ({props.get('capacity', 'N/A')})", dxfattribs={'layer': 'ANNOTATIONS', 'height': 0.5}).set_placement((x, y + 5))
            elif ctype == 'valve':
                msp.add_lwpolyline([(x-0.5, y-0.5), (x+0.5, y+0.5), (x-0.5, y+0.5), (x+0.5, y-0.5)], close=True, dxfattribs={'layer': 'VALVES'})
                msp.add_text(name, dxfattribs={'layer': 'ANNOTATIONS', 'height': 0.2}).set_placement((x, y - 1.0))
        os.makedirs('exports', exist_ok=True)
        filepath = os.path.join('exports', filename)
        doc.saveas(filepath)
        return filepath

    @staticmethod
    def export_point_cloud_to_ply(points: List[Dict], filename: str) -> str:
        os.makedirs('exports', exist_ok=True)
        filepath = os.path.join('exports', filename)
        
        # Check if points is a list of dicts with 'x','y','z' or 'pos'
        if len(points) > 0 and 'x' in points[0]:
            positions = np.array([[p['x'], p['y'], p['z']] for p in points], dtype=np.float32)
            colors = np.array([[p.get('r', 0.5), p.get('g', 0.5), p.get('b', 0.5)] for p in points], dtype=np.float32)
        else:
            positions = np.array([p['pos'] for p in points], dtype=np.float32)
            colors = np.array([p['color'] for p in points], dtype=np.float32)

        if colors.max() <= 1.0:
            colors = (colors * 255).astype(np.uint8)
        else:
            colors = colors.astype(np.uint8)

        num_points = len(points)
        with open(filepath, 'w') as f:
            f.write('ply\n')
            f.write('format ascii 1.0\n')
            f.write('comment Point cloud generated by Aether-Gen\n')
            f.write(f'element vertex {num_points}\n')
            f.write('property float x\n')
            f.write('property float y\n')
            f.write('property float z\n')
            f.write('property uchar red\n')
            f.write('property uchar green\n')
            f.write('property uchar blue\n')
            f.write('end_header\n')
            for i in range(num_points):
                pos = positions[i]
                col = colors[i]
                f.write(f'{pos[0]} {pos[1]} {pos[2]} {col[0]} {col[1]} {col[2]}\n')
        return filepath

    @staticmethod
    def export_point_cloud_to_obj(points: List[Dict], filename: str) -> str:
        os.makedirs('exports', exist_ok=True)
        filepath = os.path.join('exports', filename)
        
        if len(points) > 0 and 'x' in points[0]:
            positions = np.array([[p['x'], p['y'], p['z']] for p in points], dtype=np.float32)
            colors = np.array([[p.get('r', 0.5), p.get('g', 0.5), p.get('b', 0.5)] for p in points], dtype=np.float32)
        else:
            positions = np.array([p['pos'] for p in points], dtype=np.float32)
            colors = np.array([p['color'] for p in points], dtype=np.float32)

        if colors.max() > 1.0:
            colors = colors / 255.0

        with open(filepath, 'w') as f:
            f.write('# Point cloud generated by Aether-Gen\n')
            f.write(f'# {len(points)} vertices\n\n')
            for i, (pos, col) in enumerate(zip(positions, colors)):
                f.write(f'v {pos[0]} {pos[1]} {pos[2]} {col[0]} {col[1]} {col[2]}\n')
        return filepath

    @staticmethod
    def export_mesh_to_stl(verts: np.ndarray, faces: np.ndarray, filename: str) -> str:
        """Export a mesh (verts and faces) to an STL file."""
        os.makedirs('exports', exist_ok=True)
        filepath = os.path.join('exports', filename)
        
        # Binary STL format
        with open(filepath, 'wb') as f:
            f.write(b'\x00' * 80) # Header
            f.write(np.uint32(len(faces)).tobytes()) # Number of triangles
            
            for face in faces:
                # Calculate normal
                v0, v1, v2 = verts[face[0]], verts[face[1]], verts[face[2]]
                normal = np.cross(v1 - v0, v2 - v0)
                norm = np.linalg.norm(normal)
                if norm > 0:
                    normal /= norm
                
                f.write(normal.astype(np.float32).tobytes())
                f.write(v0.astype(np.float32).tobytes())
                f.write(v1.astype(np.float32).tobytes())
                f.write(v2.astype(np.float32).tobytes())
                f.write(np.uint16(0).tobytes()) # Attribute byte count
        return filepath

    @staticmethod
    def export_mesh_to_obj(verts: np.ndarray, faces: np.ndarray, filename: str) -> str:
        """Export a mesh (verts and faces) to an OBJ file."""
        os.makedirs('exports', exist_ok=True)
        filepath = os.path.join('exports', filename)
        with open(filepath, 'w') as f:
            f.write('# Mesh generated by Aether-Gen\n')
            for v in verts:
                f.write(f'v {v[0]} {v[1]} {v[2]}\n')
            for face in faces:
                # OBJ uses 1-based indexing for faces
                f.write(f'f {face[0]+1} {face[1]+1} {face[2]+1}\n')
        return filepath
