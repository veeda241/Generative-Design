import ezdxf
import os
import json
import numpy as np
from datetime import datetime
from typing import List, Dict, Tuple

class DXFExporter:
    @staticmethod
    def generate_dxf(design_json: dict, filename: str) -> str:
        # Create a new DXF document (R2010 is widely compatible)
        doc = ezdxf.new('R2010')
        doc.header['$INSUNITS'] = 6  # Meters
        msp = doc.modelspace()
        
        # Define Engineering Layers
        layers = [
            ('PIPING', 7),      # White/Black
            ('EQUIPMENT', 4),   # Cyan
            ('ANNOTATIONS', 3), # Green
            ('VALVES', 1)       # Red
        ]
        for name, color in layers:
            doc.layers.add(name=name, color=color)
        
        # Add Title Block
        msp.add_text(f"AETHER-GEN AUTOMATED DESIGN: {design_json.get('id', 'N/A')}", 
                    dxfattribs={'layer': 'ANNOTATIONS', 'height': 1.0}).set_placement((0, 20))
        msp.add_text(f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M')}", 
                    dxfattribs={'layer': 'ANNOTATIONS', 'height': 0.5}).set_placement((0, 18))

        for component in design_json.get('components', []):
            ctype = component.get('type')
            pos = component.get('position', [0, 0, 0])
            props = component.get('properties', {})
            name = component.get('name', 'N/A')
            
            x, y = pos[0], pos[1]
            
            if ctype == 'pipe':
                start = props.get('start_pos', pos)
                end = props.get('end_pos', [pos[0]+5, pos[1], pos[2]])
                msp.add_line((start[0], start[1]), (end[0], end[1]), dxfattribs={'layer': 'PIPING'})
                
                # Centerline Annotation
                mid = ((start[0]+end[0])/2, (start[1]+end[1])/2)
                msp.add_text(f"PIPE {props.get('diameter', 4)}\" - {name}", 
                            dxfattribs={'layer': 'ANNOTATIONS', 'height': 0.2}).set_placement((mid[0], mid[1] + 0.3))
                
            elif ctype == 'pump':
                # Drawing a simplified pump symbol (Rectangle + Circle)
                msp.add_lwpolyline([(x-0.8, y-0.5), (x+0.8, y-0.5), (x+0.8, y+0.5), (x-0.8, y+0.5)], 
                                  close=True, dxfattribs={'layer': 'EQUIPMENT'})
                msp.add_circle((x, y), radius=0.3, dxfattribs={'layer': 'EQUIPMENT'})
                msp.add_text(f"PUMP: {name}", dxfattribs={'layer': 'ANNOTATIONS', 'height': 0.3}).set_placement((x, y + 1.2))
                
            elif ctype == 'tank':
                # Circle with ID
                msp.add_circle((x, y), radius=4, dxfattribs={'layer': 'EQUIPMENT'})
                msp.add_text(f"TANK ({props.get('capacity', 'N/A')})", 
                            dxfattribs={'layer': 'ANNOTATIONS', 'height': 0.5}).set_placement((x, y + 5))
                
            elif ctype == 'valve':
                # Butterfly valve symbol (two triangles)
                msp.add_lwpolyline([(x-0.5, y-0.5), (x+0.5, y+0.5), (x-0.5, y+0.5), (x+0.5, y-0.5)], 
                                  close=True, dxfattribs={'layer': 'VALVES'})
                msp.add_text(name, dxfattribs={'layer': 'ANNOTATIONS', 'height': 0.2}).set_placement((x, y - 1.0))

        # Ensure directory and save
        os.makedirs('exports', exist_ok=True)
        filepath = os.path.join('exports', filename)
        doc.saveas(filepath)
        return filepath

    @staticmethod
    def export_point_cloud_to_ply(points: List[Dict], filename: str) -> str:
        """
        Export point cloud to PLY (Polygon File) format.
        
        Args:
            points: List of dicts with 'pos' and 'color' keys
            filename: Output filename (should end with .ply)
            
        Returns:
            Path to saved file
        """
        os.makedirs('exports', exist_ok=True)
        filepath = os.path.join('exports', filename)
        
        # Extract positions and colors
        positions = np.array([p['pos'] for p in points], dtype=np.float32)
        colors = np.array([p['color'] for p in points], dtype=np.uint8)
        
        # Normalize colors to 0-255 if needed
        if colors.max() <= 1.0:
            colors = (colors * 255).astype(np.uint8)
        
        num_points = len(points)
        
        # Write PLY file
        with open(filepath, 'w') as f:
            # Write header
            f.write('ply\n')
            f.write('format ascii 1.0\n')
            f.write('comment Point cloud generated by Point-E\n')
            f.write(f'element vertex {num_points}\n')
            f.write('property float x\n')
            f.write('property float y\n')
            f.write('property float z\n')
            f.write('property uchar red\n')
            f.write('property uchar green\n')
            f.write('property uchar blue\n')
            f.write('end_header\n')
            
            # Write vertices
            for i in range(num_points):
                pos = positions[i]
                col = colors[i]
                f.write(f'{pos[0]} {pos[1]} {pos[2]} {col[0]} {col[1]} {col[2]}\n')
        
        return filepath

    @staticmethod
    def export_point_cloud_to_obj(points: List[Dict], filename: str) -> str:
        """
        Export point cloud to OBJ (Wavefront) format.
        
        Args:
            points: List of dicts with 'pos' and 'color' keys
            filename: Output filename (should end with .obj)
            
        Returns:
            Path to saved file
        """
        os.makedirs('exports', exist_ok=True)
        filepath = os.path.join('exports', filename)
        
        # Extract positions and colors
        positions = np.array([p['pos'] for p in points], dtype=np.float32)
        colors = np.array([p['color'] for p in points], dtype=np.uint8)
        
        # Normalize colors to 0-1 range for OBJ
        if colors.max() > 1.0:
            colors = colors / 255.0
        
        # Write OBJ file
        with open(filepath, 'w') as f:
            f.write('# Point cloud generated by Point-E\n')
            f.write(f'# {len(points)} vertices\n\n')
            
            # Write vertices with colors
            for i, (pos, col) in enumerate(zip(positions, colors)):
                f.write(f'v {pos[0]} {pos[1]} {pos[2]} {col[0]} {col[1]} {col[2]}\n')
        
        return filepath

    @staticmethod
    def export_mesh_to_stl(vertices: np.ndarray, faces: np.ndarray, filename: str) -> str:
        """
        Export mesh to STL (Stereolithography) format.
        
        Args:
            vertices: Nx3 array of vertex positions
            faces: Nx3 array of vertex indices forming triangles
            filename: Output filename (should end with .stl)
            
        Returns:
            Path to saved file
        """
        os.makedirs('exports', exist_ok=True)
        filepath = os.path.join('exports', filename)
        
        with open(filepath, 'wb') as f:
            # Write 80-byte header
            f.write(b'Binary STL file from Point-E Point Cloud\x00' + b'\x00' * 39)
            
            # Write number of triangles
            num_triangles = len(faces)
            f.write(num_triangles.to_bytes(4, byteorder='little'))
            
            # Write triangles
            for face in faces:
                v1 = vertices[face[0]]
                v2 = vertices[face[1]]
                v3 = vertices[face[2]]
                
                # Calculate normal
                e1 = v2 - v1
                e2 = v3 - v1
                normal = np.cross(e1, e2)
                norm = np.linalg.norm(normal)
                if norm > 0:
                    normal = normal / norm
                
                # Write normal
                f.write(np.array(normal, dtype=np.float32).tobytes())
                
                # Write vertices
                f.write(np.array(v1, dtype=np.float32).tobytes())
                f.write(np.array(v2, dtype=np.float32).tobytes())
                f.write(np.array(v3, dtype=np.float32).tobytes())
                
                # Write attribute byte count
                f.write((0).to_bytes(2, byteorder='little'))
        
        return filepath
